name: Python FastAPI CI/CD

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'demos/python-fastapi/**'
      - '.github/workflows/python-fastapi-ci.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'demos/python-fastapi/**'
      - '.github/workflows/python-fastapi-ci.yml'

env:
  WORKING_DIR: demos/python-fastapi
  IMAGE_NAME: python-fastapi
  MAX_IMAGE_SIZE_MB: 100

jobs:
  # Pre-build Security and Quality Checks
  pre-build-checks:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ['3.9', '3.10', '3.11', '3.12']
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
        cache: 'pip'
        cache-dependency-path: '${{ env.WORKING_DIR }}/requirements-dev.txt'
    
    - name: Install dependencies
      working-directory: ${{ env.WORKING_DIR }}
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements-dev.txt
    
    - name: Check for secrets in code
      run: |
        # Advanced secret detection with multiple patterns
        echo "üîç Scanning for hardcoded secrets..."
        
        # Pattern 1: Traditional secrets (password, api_key, secret, token)
        BASIC_SECRETS=$(grep -r -E "(password|api_key|secret|token).*=.*['\"][^'\"]{10,}" ${{ env.WORKING_DIR }}/app/ --include="*.py" | \
          grep -v -E "(os\.getenv|os\.environ|self\.|change-in-production|your-|dev-|test-|placeholder|example|demo)" || true)
        
        # Pattern 2: Password-like strings with special characters (e.g., "Pass!23", "MySecret@123")
        PASSWORD_LIKE=$(grep -r -E "(password|secret|key|token).*=.*['\"][^'\"]*[!@#$%^&*()_+=\-\[\]{}|\\:;\"'<>?,./][^'\"]*[0-9]" ${{ env.WORKING_DIR }}/app/ --include="*.py" | \
          grep -v -E "(os\.getenv|os\.environ|self\.|change-in-production|your-|dev-|test-|placeholder|example|demo)" || true)
        
        # Pattern 3: Base64-like encoded strings (common for secrets)
        BASE64_SECRETS=$(grep -r -E "(password|secret|key|token).*=.*['\"][A-Za-z0-9+/]{20,}[=]{0,2}['\"]" ${{ env.WORKING_DIR }}/app/ --include="*.py" | \
          grep -v -E "(os\.getenv|os\.environ|self\.|change-in-production|your-|dev-|test-|placeholder|example|demo)" || true)
        
        # Pattern 4: JWT tokens or API keys (long alphanumeric strings)
        TOKEN_LIKE=$(grep -r -E "(jwt|bearer|auth).*['\"][A-Za-z0-9]{32,}['\"]" ${{ env.WORKING_DIR }}/app/ --include="*.py" | \
          grep -v -E "(os\.getenv|os\.environ|self\.|change-in-production|your-|dev-|test-|placeholder|example|demo)" || true)
        
        # Combine all findings
        ALL_SECRETS="$BASIC_SECRETS$PASSWORD_LIKE$BASE64_SECRETS$TOKEN_LIKE"
        
        if [ -n "$ALL_SECRETS" ]; then
          echo "‚ùå Potential hardcoded secrets found!"
          [ -n "$BASIC_SECRETS" ] && echo "Basic secrets:" && echo "$BASIC_SECRETS"
          [ -n "$PASSWORD_LIKE" ] && echo "Password-like patterns:" && echo "$PASSWORD_LIKE"  
          [ -n "$BASE64_SECRETS" ] && echo "Base64-like secrets:" && echo "$BASE64_SECRETS"
          [ -n "$TOKEN_LIKE" ] && echo "Token-like patterns:" && echo "$TOKEN_LIKE"
          exit 1
        else
          echo "‚úÖ No hardcoded secrets detected"
        fi
    
    - name: Dependency vulnerability scan
      working-directory: ${{ env.WORKING_DIR }}
      run: |
        pip install safety
        safety check --json --output safety-report.json || true
        if [ -s safety-report.json ] && [ "$(jq length safety-report.json)" -gt 0 ]; then
          echo "‚ùå Vulnerable dependencies found!"
          cat safety-report.json
          exit 1
        else
          echo "‚úÖ No vulnerable dependencies found"
        fi
    
    - name: Code quality checks
      working-directory: ${{ env.WORKING_DIR }}
      run: |
        echo "üîç Running code quality checks..."
        
        # Basic syntax and import check
        find app/ -name "*.py" -exec python -m py_compile {} \;
        echo "‚úÖ Python syntax OK"
        
        # Linting (with relaxed rules to avoid formatter conflicts)
        flake8 app/ --extend-ignore=E203,W503,E501 --max-line-length=100 || (echo "‚ùå Critical linting issues found" && exit 1)
        echo "‚úÖ Linting OK"
        
        # Type checking
        mypy app/ --ignore-missing-imports || echo "‚ö†Ô∏è Type checking issues found (non-blocking)"
        echo "‚úÖ Type checking completed"
    
    - name: Security scanning (Bandit)
      working-directory: ${{ env.WORKING_DIR }}
      run: |
        bandit -r app/ -f json -o bandit-report.json
        if [ -s bandit-report.json ]; then
          HIGH_ISSUES=$(jq '[.results[] | select(.issue_severity == "HIGH")] | length' bandit-report.json)
          MEDIUM_ISSUES=$(jq '[.results[] | select(.issue_severity == "MEDIUM")] | length' bandit-report.json)
          
          if [ "$HIGH_ISSUES" -gt 0 ]; then
            echo "‚ùå High severity security issues found: $HIGH_ISSUES"
            jq '.results[] | select(.issue_severity == "HIGH")' bandit-report.json
            exit 1
          elif [ "$MEDIUM_ISSUES" -gt 5 ]; then
            echo "‚ùå Too many medium security issues: $MEDIUM_ISSUES (max: 5)"
            exit 1
          else
            echo "‚úÖ Security scan passed (High: $HIGH_ISSUES, Medium: $MEDIUM_ISSUES)"
          fi
        fi
    
    - name: Test structure validation
      working-directory: ${{ env.WORKING_DIR }}
      run: |
        echo "üß™ Validating test structure..."
        
        # Check if tests exist
        if [ ! -d "app/tests" ]; then
          echo "‚ùå Tests directory not found!"
          exit 1
        fi
        
        # Count test files
        TEST_FILES=$(find app/tests -name "test_*.py" | wc -l)
        if [ "$TEST_FILES" -lt 3 ]; then
          echo "‚ùå Insufficient test files found: $TEST_FILES (minimum: 3)"
          exit 1
        fi
        
        echo "‚úÖ Test structure validated ($TEST_FILES test files found)"
    
    - name: GitIgnore validation
      working-directory: ${{ env.WORKING_DIR }}
      run: |
        echo "üìã Validating .gitignore coverage..."
        
        # Check if .gitignore exists
        if [ ! -f ".gitignore" ]; then
          echo "‚ùå .gitignore file not found!"
          exit 1
        fi
        
        # Check for critical patterns in Python projects
        CRITICAL_PATTERNS=(
          "__pycache__"
          "*.pyc" 
          ".env"
          "*.log"
          ".DS_Store"
          ".coverage"
          ".pytest_cache"
          "*.egg-info"
        )
        
        MISSING_PATTERNS=()
        for pattern in "${CRITICAL_PATTERNS[@]}"; do
          if ! grep -q "$pattern" .gitignore; then
            MISSING_PATTERNS+=("$pattern")
          fi
        done
        
        if [ ${#MISSING_PATTERNS[@]} -gt 0 ]; then
          echo "‚ùå Critical .gitignore patterns missing:"
          printf '%s\n' "${MISSING_PATTERNS[@]}"
          exit 1
        fi
        
        echo "‚úÖ .gitignore validation passed"
    
    - name: Upload security scan results
      uses: github/codeql-action/upload-sarif@v3
      if: always() && hashFiles(format('{0}/bandit-report.json', env.WORKING_DIR))
      with:
        sarif_file: ${{ env.WORKING_DIR }}/bandit-report.json
      continue-on-error: true

  # Testing
  test:
    runs-on: ubuntu-latest
    needs: pre-build-checks
    
    services:
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: 'pip'
        cache-dependency-path: '${{ env.WORKING_DIR }}/requirements-dev.txt'
    
    - name: Install dependencies
      working-directory: ${{ env.WORKING_DIR }}
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements-dev.txt
    
    - name: Run tests with coverage
      working-directory: ${{ env.WORKING_DIR }}
      run: |
        pytest app/tests/ -v \
          --cov=app \
          --cov-report=xml \
          --cov-report=html \
          --cov-report=term-missing \
          --junitxml=pytest-report.xml \
          --tb=short
    
    - name: Coverage validation
      working-directory: ${{ env.WORKING_DIR }}
      run: |
        COVERAGE=$(python -c "import xml.etree.ElementTree as ET; tree = ET.parse('coverage.xml'); print(float(tree.getroot().attrib['line-rate']) * 100)")
        echo "Code coverage: ${COVERAGE}%"
        if (( $(echo "$COVERAGE < 80" | bc -l) )); then
          echo "‚ùå Code coverage below 80%: ${COVERAGE}%"
          exit 1
        else
          echo "‚úÖ Code coverage meets minimum threshold: ${COVERAGE}%"
        fi
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ${{ env.WORKING_DIR }}/coverage.xml
        flags: python-fastapi
        name: python-fastapi-coverage

  # Docker Build and Security Scan
  docker-build:
    runs-on: ubuntu-latest
    needs: test
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Build Docker image
      working-directory: ${{ env.WORKING_DIR }}
      run: |
        docker build -t ${{ env.IMAGE_NAME }}:test .
        
        # Get image size
        IMAGE_SIZE_BYTES=$(docker image inspect ${{ env.IMAGE_NAME }}:test --format='{{.Size}}')
        IMAGE_SIZE_MB=$((IMAGE_SIZE_BYTES / 1024 / 1024))
        
        echo "Docker image size: ${IMAGE_SIZE_MB}MB"
        echo "IMAGE_SIZE_MB=${IMAGE_SIZE_MB}" >> $GITHUB_ENV
        
        if [ "$IMAGE_SIZE_MB" -gt "${{ env.MAX_IMAGE_SIZE_MB }}" ]; then
          echo "‚ùå Docker image too large: ${IMAGE_SIZE_MB}MB (max: ${{ env.MAX_IMAGE_SIZE_MB }}MB)"
          exit 1
        else
          echo "‚úÖ Docker image size acceptable: ${IMAGE_SIZE_MB}MB"
        fi
    
    - name: Test Docker image functionality
      working-directory: ${{ env.WORKING_DIR }}
      run: |
        echo "üê≥ Testing Docker container functionality..."
        
        # Start container
        CONTAINER_ID=$(docker run -d -p 8080:8000 ${{ env.IMAGE_NAME }}:test)
        echo "Started container: $CONTAINER_ID"
        
        # Wait for startup
        sleep 15
        
        # Test health endpoint
        if curl -f --max-time 10 http://localhost:8080/health/; then
          echo "‚úÖ Health check passed"
        else
          echo "‚ùå Health check failed"
          docker logs $CONTAINER_ID
          exit 1
        fi
        
        # Test API functionality
        if curl -f --max-time 10 http://localhost:8080/; then
          echo "‚úÖ API root endpoint accessible"
        else
          echo "‚ùå API root endpoint failed"
          docker logs $CONTAINER_ID
          exit 1
        fi
        
        # Test task creation
        TASK_RESPONSE=$(curl -s -X POST http://localhost:8080/api/v1/tasks/ \
          -H "Content-Type: application/json" \
          -d '{"title":"Test Task","description":"CI/CD Test","priority":"high"}')
        
        if echo "$TASK_RESPONSE" | jq -e '.id' > /dev/null; then
          echo "‚úÖ Task creation successful"
        else
          echo "‚ùå Task creation failed: $TASK_RESPONSE"
          exit 1
        fi
        
        # Cleanup
        docker stop $CONTAINER_ID
        docker rm $CONTAINER_ID
    
    - name: Network security scan
      run: |
        echo "üîí Checking container network security..."
        
        # Start container for network analysis
        CONTAINER_ID=$(docker run -d ${{ env.IMAGE_NAME }}:test)
        
        # Check open ports
        OPEN_PORTS=$(docker port $CONTAINER_ID | wc -l)
        echo "Open ports: $OPEN_PORTS"
        
        # Check for suspicious network configurations
        if docker exec $CONTAINER_ID netstat -tuln 2>/dev/null | grep -E ':22|:23|:3389'; then
          echo "‚ùå Suspicious ports detected (SSH, Telnet, RDP)"
          docker stop $CONTAINER_ID
          docker rm $CONTAINER_ID
          exit 1
        else
          echo "‚úÖ No suspicious network ports detected"
        fi
        
        # Cleanup
        docker stop $CONTAINER_ID
        docker rm $CONTAINER_ID
    
    - name: Container security scan (Trivy)
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: '${{ env.IMAGE_NAME }}:test'
        format: 'sarif'
        output: 'trivy-results.sarif'
        severity: 'HIGH,CRITICAL'
        exit-code: 1
    
    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  # Container Structure Tests
  container-structure-test:
    runs-on: ubuntu-latest
    needs: docker-build
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Build Docker image
      working-directory: ${{ env.WORKING_DIR }}
      run: docker build -t ${{ env.IMAGE_NAME }}:test .
    
    - name: Run container structure tests
      uses: plexsystems/container-structure-test-action@v0.3.0
      with:
        image: '${{ env.IMAGE_NAME }}:test'
        config: '${{ env.WORKING_DIR }}/container-structure-test.yaml'

  # Performance Testing
  performance-test:
    runs-on: ubuntu-latest
    needs: container-structure-test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Build and start services
      working-directory: ${{ env.WORKING_DIR }}
      run: |
        docker-compose up -d
        sleep 30
    
    - name: Install performance testing tools
      run: |
        sudo apt-get update
        sudo apt-get install -y apache2-utils jq bc
    
    - name: Performance benchmarks
      run: |
        echo "üöÄ Running performance benchmarks..."
        
        # Health endpoint performance
        echo "Testing health endpoint..."
        ab -n 100 -c 10 -q http://localhost:8000/health/ > health_perf.txt
        HEALTH_RPS=$(grep "Requests per second:" health_perf.txt | awk '{print $4}' | cut -d'.' -f1)
        echo "Health endpoint RPS: $HEALTH_RPS"
        
        if [ "$HEALTH_RPS" -lt 100 ]; then
          echo "‚ùå Health endpoint performance below threshold: ${HEALTH_RPS} RPS (min: 100)"
          exit 1
        fi
        
        # API endpoint performance
        echo "Testing API root endpoint..."
        ab -n 50 -c 5 -q http://localhost:8000/ > api_perf.txt
        API_RPS=$(grep "Requests per second:" api_perf.txt | awk '{print $4}' | cut -d'.' -f1)
        echo "API root RPS: $API_RPS"
        
        if [ "$API_RPS" -lt 50 ]; then
          echo "‚ùå API performance below threshold: ${API_RPS} RPS (min: 50)"
          exit 1
        fi
        
        # Memory usage check
        echo "Checking memory usage..."
        MEMORY_USAGE=$(docker stats --no-stream --format "{{.MemUsage}}" | head -1 | cut -d'/' -f1 | sed 's/MiB//')
        echo "Memory usage: ${MEMORY_USAGE}MB"
        
        if (( $(echo "$MEMORY_USAGE > 256" | bc -l) )); then
          echo "‚ùå Memory usage too high: ${MEMORY_USAGE}MB (max: 256MB)"
          exit 1
        else
          echo "‚úÖ Memory usage acceptable: ${MEMORY_USAGE}MB"
        fi
        
        echo "‚úÖ All performance benchmarks passed"
    
    - name: Cleanup
      working-directory: ${{ env.WORKING_DIR }}
      if: always()
      run: docker-compose down

  # Final validation and reporting
  final-validation:
    runs-on: ubuntu-latest
    needs: [pre-build-checks, test, docker-build, container-structure-test, performance-test]
    if: always()
    
    steps:
    - name: Validation Summary
      run: |
        echo "## üéØ CI/CD Pipeline Summary" >> $GITHUB_STEP_SUMMARY
        echo "| Check | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
        echo "| Pre-build Security | ${{ needs.pre-build-checks.result == 'success' && '‚úÖ Pass' || '‚ùå Fail' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Tests | ${{ needs.test.result == 'success' && '‚úÖ Pass' || '‚ùå Fail' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Docker Build | ${{ needs.docker-build.result == 'success' && '‚úÖ Pass' || '‚ùå Fail' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Container Structure | ${{ needs.container-structure-test.result == 'success' && '‚úÖ Pass' || '‚ùå Fail' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Performance | ${{ needs.performance-test.result == 'success' && '‚úÖ Pass' || '‚ùå Fail' }} |" >> $GITHUB_STEP_SUMMARY
        
        if [[ "${{ needs.pre-build-checks.result }}" == "success" && "${{ needs.test.result }}" == "success" && "${{ needs.docker-build.result }}" == "success" && "${{ needs.container-structure-test.result }}" == "success" ]]; then
          echo "## ‚úÖ All Checks Passed!" >> $GITHUB_STEP_SUMMARY
          echo "The Python FastAPI demo is ready for deployment." >> $GITHUB_STEP_SUMMARY
        else
          echo "## ‚ùå Some Checks Failed" >> $GITHUB_STEP_SUMMARY
          echo "Please review the failed jobs and fix the issues." >> $GITHUB_STEP_SUMMARY
        fi